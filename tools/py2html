#!/usr/bin/env python

"""Convert Python source code to colored HTML."""

# Based on 'Colorize Python source using the built-in tokenizer'
# by Juergen Hermann
# http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52298


import cStringIO
import cgi
import keyword
import re
import sys
import token
import tokenize


RE_NEWLINE = re.compile(r"\n(?!<a name=)", re.MULTILINE)

KEYWORD = token.NT_OFFSET + 1
TEXT = token.NT_OFFSET + 2

CSS_CLASSES = {
    KEYWORD:          "python-keyword",
    TEXT:             "python-text",
    token.ERRORTOKEN: "python-error",
    token.NAME:       "python-name",
    token.NUMBER:     "python-number",
    token.OP:         "python-operator",
    token.STRING:     "python-string",
    tokenize.COMMENT: "python-comment",}


class Parser(object):

    """Convert Python source code to colored HTML."""

    # pylint: disable-msg=W0612
    def __call__(self, toktype, toktext, (srow, scol), (erow, ecol), line):
        """Write token text to self.out."""

        old_pos = self.pos
        new_pos = self.offsets[srow] + scol
        self.pos = new_pos + len(toktext)
        if toktype in (token.NEWLINE, tokenize.NL):
            return self.out.write(self.get_newline())
        if new_pos > old_pos:
            self.out.write(self.raw[old_pos:new_pos])
        if toktype in (token.INDENT, token.DEDENT):
            self.pos = new_pos
            return

        if token.LPAR <= toktype and toktype <= token.OP:
            toktype = token.OP
        elif toktype == token.NAME and keyword.iskeyword(toktext):
            toktype = KEYWORD
        css_class = CSS_CLASSES.get(toktype, "python-text")
        self.out.write('<span class="%s">' % css_class)
        toktext = cgi.escape(toktext) + "</span>"
        toktext = toktext.replace("\n</span>", "</span>\n")
        toktext = RE_NEWLINE.sub(self.get_newline, toktext)
        self.out.write(toktext)

    def __init__(self, raw, out):

        self.line = 0
        self.offsets = [0, 0]
        self.out = out
        self.pos = 0
        self.raw = raw.strip()

    def format(self):
        """Parse self.raw and send colored HTML to self.out."""

        lines = self.raw.split("\n")
        for i in range(1, len(lines) + 1):
            pos = sum(tuple(len(x) + 1 for x in lines[:i]))
            self.offsets.append(pos)

        text = cStringIO.StringIO(self.raw)
        self.out.write(self.get_newline().replace("\n", ""))
        try:
            tokenize.tokenize(text.readline, self)
        except tokenize.TokenError, obj:
            sys.stderr.write(obj[0], obj[1][0])
            raise SystemExit(1)
        self.out.write("\n")

    def get_newline(self, *args):
        """Get newline followed by a line number anchor."""

        self.line += 1
        return '\n<a name="L%d" class="line-number">%4.0d </a>' % (
            self.line, self.line)


def convert(source, destination=sys.stdout):
    """Convert Python source code to colored HTML."""

    source = open(source, "r").read()
    if isinstance(destination, basestring):
        destination = open(destination, "w")
    Parser(source, destination).format()


if __name__ == "__main__":
    convert(sys.argv[1])
